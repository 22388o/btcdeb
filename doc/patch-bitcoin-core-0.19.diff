diff --git a/Makefile.am b/Makefile.am
index 9f70e95..730166d 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -46,6 +46,7 @@ BITCOIN_CORE_H = \
 	$(LIBBITCOIN_DEB_H) \
 	amount.h \
 	arith_uint256.h \
+	attributes.h \
 	base58.h \
 	bech32.h \
 	compat.h \
@@ -75,7 +76,7 @@ BITCOIN_CORE_H = \
 	support/lockedpool.h \
 	tinyformat.h \
 	uint256.h \
-	utilstrencodings.h \
+	util/strencodings.h \
 	value.h
 
 # debugger #
@@ -111,7 +112,7 @@ libbitcoin_a_SOURCES = \
 	support/cleanse.cpp \
 	support/lockedpool.cpp \
 	uint256.cpp \
-	utilstrencodings.cpp \
+	util/strencodings.cpp \
 	value.cpp \
     $(BITCOIN_CORE_H)
 
diff --git a/btcdeb.cpp b/btcdeb.cpp
index 7ac39a1..75ca3cf 100644
--- a/btcdeb.cpp
+++ b/btcdeb.cpp
@@ -211,7 +211,7 @@ int main(int argc, char* const* argv)
 
     script_ptrs.push_back(&env->script);
     script_headers.push_back("");
-    CScriptIter it = env->script.begin();
+    CScript::const_iterator it = env->script.begin();
     opcodetype opcode;
     valtype vchPushValue, p2sh_script_payload;
     while (env->script.GetOp(it, opcode, vchPushValue)) { p2sh_script_payload = vchPushValue; ++count; }
diff --git a/configure.ac b/configure.ac
index 05bcfa6..72f24a7 100644
--- a/configure.ac
+++ b/configure.ac
@@ -2,7 +2,7 @@ dnl require autoconf 2.60 (AS_ECHO/AS_ECHO_N)
 AC_PREREQ([2.60])
 define(_CLIENT_VERSION_MAJOR, 0)
 define(_CLIENT_VERSION_MINOR, 2)
-define(_CLIENT_VERSION_REVISION, 16)
+define(_CLIENT_VERSION_REVISION, 19)
 define(_CLIENT_VERSION_BUILD, 0)
 define(_CLIENT_VERSION_IS_RELEASE, false)
 define(_COPYRIGHT_YEAR, 2020)
diff --git a/debugger/interpreter.h b/debugger/interpreter.h
index 9f3d4de..fcab96a 100644
--- a/debugger/interpreter.h
+++ b/debugger/interpreter.h
@@ -6,7 +6,7 @@
 #define BITCOIN_BTCDEB_INTERPRETER_H
 
 #include <script/interpreter.h>
-#include <utilstrencodings.h> // HexStr
+#include <util/strencodings.h> // HexStr
 
 template <typename T, typename T2> static inline void print_vec(const T& v, T2 fun) {
     for (unsigned char c : v) fun("%02x", c);
@@ -50,10 +50,10 @@ static inline void _popstack(std::vector<valtype>& stack)
 #define pushstack(stack, v) do { stack.push_back(v); btc_logf("\t\t<> PUSH " #stack " %s\n", HexStr(stack.at(stack.size()-1)).c_str()); } while (0)
 
 struct InterpreterEnv : public ScriptExecutionEnvironment {
-    CScriptIter pc;
+    CScript::const_iterator pc;
     std::vector<stack_type> stack_history;
     std::vector<stack_type> altstack_history;
-    std::vector<CScriptIter> pc_history;
+    std::vector<CScript::const_iterator> pc_history;
     std::vector<int> nOpCount_history;
     std::vector<CScript> script_history;
     const CScript& scriptIn;
diff --git a/debugger/script.cpp b/debugger/script.cpp
index ca7688e..77fa517 100644
--- a/debugger/script.cpp
+++ b/debugger/script.cpp
@@ -4,7 +4,7 @@
 
 #include <debugger/script.h>
 
-// #include <utilstrencodings.h>
+// #include <util/strencodings.h>
 #include <cstdarg>
 
 void btc_logf_dummy(const char* fmt...) {}
diff --git a/functions.cpp b/functions.cpp
index 2aae8f8..fc8d0a2 100644
--- a/functions.cpp
+++ b/functions.cpp
@@ -29,7 +29,7 @@ int fn_rewind(const char* arg) {
     return 0;
 }
 
-inline void svprintscripts(std::vector<std::string>& l, int& lmax, std::vector<CScript*>& scripts, std::vector<std::string>& headers, CScriptIter it) {
+inline void svprintscripts(std::vector<std::string>& l, int& lmax, std::vector<CScript*>& scripts, std::vector<std::string>& headers, CScript::const_iterator it) {
     char buf[1024];
     opcodetype opcode;
     valtype vchPushValue;
@@ -86,7 +86,7 @@ void print_dualstack() {
         headers.push_back("<<< scriptPubKey >>>");
         if ((env->flags & SCRIPT_VERIFY_P2SH) && env->successor_script.IsPayToScriptHash()) {
             has_p2sh = true;
-            CScriptIter it = env->script.begin();
+            CScript::const_iterator it = env->script.begin();
             opcodetype opcode;
             valtype vchPushValue, p2sh_script_payload;
             while (env->script.GetOp(it, opcode, vchPushValue)) { p2sh_script_payload = vchPushValue; }
diff --git a/hash.cpp b/hash.cpp
index 26150e5..9a40469 100644
--- a/hash.cpp
+++ b/hash.cpp
@@ -1,11 +1,13 @@
-// Copyright (c) 2013-2018 The Bitcoin Core developers
+// Copyright (c) 2013-2016 The Bitcoin Core developers
 // Distributed under the MIT software license, see the accompanying
 // file COPYING or http://www.opensource.org/licenses/mit-license.php.
 
 #include <hash.h>
 #include <crypto/common.h>
 #include <crypto/hmac_sha512.h>
+// #include <pubkey.h>
 
+bool CHashWriter::debug = false;
 
 inline uint32_t ROTL32(uint32_t x, int8_t r)
 {
diff --git a/hash.h b/hash.h
index c295568..e3696bd 100644
--- a/hash.h
+++ b/hash.h
@@ -1,21 +1,24 @@
 // Copyright (c) 2009-2010 Satoshi Nakamoto
-// Copyright (c) 2009-2018 The Bitcoin Core developers
+// Copyright (c) 2009-2016 The Bitcoin Core developers
 // Distributed under the MIT software license, see the accompanying
 // file COPYING or http://www.opensource.org/licenses/mit-license.php.
 
 #ifndef BITCOIN_HASH_H
 #define BITCOIN_HASH_H
 
-#include <crypto/common.h>
 #include <crypto/ripemd160.h>
 #include <crypto/sha256.h>
 #include <prevector.h>
 #include <serialize.h>
 #include <uint256.h>
-#include <version.h>
+// #include <version.h>
 
 #include <vector>
 
+// version.h {
+static const int PROTOCOL_VERSION = 70015;
+// } // version.h
+
 typedef uint256 ChainCode;
 
 /** A hasher class for Bitcoin's 256-bit hash (double SHA-256). */
@@ -122,6 +125,7 @@ private:
     const int nType;
     const int nVersion;
 public:
+    static bool debug;
 
     CHashWriter(int nTypeIn, int nVersionIn) : nType(nTypeIn), nVersion(nVersionIn) {}
 
@@ -129,6 +133,10 @@ public:
     int GetVersion() const { return nVersion; }
 
     void write(const char *pch, size_t size) {
+        if (debug) {
+            printf("#%03zu ", size); for (size_t i = 0; i < size; i++) printf("%02x", (uint8_t)pch[i]);
+            printf("\n");
+        }
         ctx.Write((const unsigned char*)pch, size);
     }
 
@@ -139,15 +147,6 @@ public:
         return result;
     }
 
-    /**
-     * Returns the first 64 bits from the resulting hash.
-     */
-    inline uint64_t GetCheapHash() {
-        unsigned char result[CHash256::OUTPUT_SIZE];
-        ctx.Finalize(result);
-        return ReadLE64(result);
-    }
-
     template<typename T>
     CHashWriter& operator<<(const T& obj) {
         // Serialize to this stream
@@ -183,7 +182,7 @@ public:
     }
 
     template<typename T>
-    CHashVerifier<Source>& operator>>(T&& obj)
+    CHashVerifier<Source>& operator>>(T& obj)
     {
         // Unserialize from this stream
         ::Unserialize(*this, obj);
diff --git a/instance.cpp b/instance.cpp
index 27ed452..86fea5d 100644
--- a/instance.cpp
+++ b/instance.cpp
@@ -1,5 +1,5 @@
 #include <script/interpreter.h>
-#include <utilstrencodings.h>
+#include <util/strencodings.h>
 #include <policy/policy.h>
 #include <streams.h>
 #include <pubkey.h>
@@ -244,7 +244,7 @@ bool Instance::eval(const size_t argc, char* const* argv) {
         fprintf(stderr, "error: invalid opcode %s\n", v);
         return false;
     }
-    CScriptIter it = script.begin();
+    CScript::const_iterator it = script.begin();
     while (it != script.end()) {
         if (!StepScript(*env, it, &script)) {
             fprintf(stderr, "Error: %s\n", ScriptErrorString(*env->serror));
@@ -335,7 +335,7 @@ bool Instance::configure_tx_txin() {
             }
             validation = CScript(pushval.begin(), pushval.end());
             hashsrc = Value(pushval);
-            CScriptIter it = scriptPubKey.begin();
+            CScript::const_iterator it = scriptPubKey.begin();
             btc_segwit_logf("hash source = %s\n", hashsrc.hex_str().c_str());
             // TODO: run this using interpreter instead
             if (!scriptPubKey.GetOp(it, opcode, pushval)) {
@@ -374,7 +374,7 @@ bool Instance::configure_tx_txin() {
                 fprintf(stderr, "expected 22 or 34 byte script inside %s, but got %zu bytes\n", source.c_str(), pushval.size());
                 return false;
         }
-        CScriptIter it = validation.begin();
+        CScript::const_iterator it = validation.begin();
         if (!validation.GetOp(it, opcode, pushval)) {
             fprintf(stderr, "can't parse %s, or %s ended prematurely\n", source.c_str(), source.c_str());
             return false;
diff --git a/instance.h b/instance.h
index 7b4e2e5..0c19cba 100644
--- a/instance.h
+++ b/instance.h
@@ -2,7 +2,7 @@
 #define included_btcdeb_instance_h_
 
 #include <debugger/interpreter.h>
-#include <utilstrencodings.h>
+#include <util/strencodings.h>
 #include <policy/policy.h>
 #include <streams.h>
 #include <pubkey.h>
diff --git a/merkle.cpp b/merkle.cpp
index 359f79e..0afc925 100644
--- a/merkle.cpp
+++ b/merkle.cpp
@@ -4,7 +4,7 @@
 
 #include <merkle.h>
 #include <hash.h>
-#include <utilstrencodings.h>
+#include <util/strencodings.h>
 
 /*     WARNING! If you're reading this because you're learning about crypto
        and/or designing a new system that will use merkle trees, keep in mind
diff --git a/policy/policy.h b/policy/policy.h
index ebe040f..5898e91 100644
--- a/policy/policy.h
+++ b/policy/policy.h
@@ -6,48 +6,34 @@
 #ifndef BITCOIN_POLICY_POLICY_H
 #define BITCOIN_POLICY_POLICY_H
 
-#include <consensus/consensus.h>
-#include <policy/feerate.h>
+// #include <consensus/consensus.h>
+// #include <policy/feerate.h>
 #include <script/interpreter.h>
-#include <script/standard.h>
+// #include <script/standard.h>
 
 #include <string>
 
-class CCoinsViewCache;
-class CTxOut;
+// script/standard.h {
+/**
+ * Mandatory script verification flags that all new blocks must comply with for
+ * them to be valid. (but old blocks may not comply with) Currently just P2SH,
+ * but in the future other flags may be added, such as a soft-fork to enforce
+ * strict DER encoding.
+ *
+ * Failing one of these tests may trigger a DoS ban - see CheckInputs() for
+ * details.
+ */
+static const unsigned int MANDATORY_SCRIPT_VERIFY_FLAGS = SCRIPT_VERIFY_P2SH;
+// }
+
+// consensus/consensus.h {
+/** Flags for nSequence and nLockTime locks */
+/** Interpret sequence numbers as relative lock-time constraints. */
+static constexpr unsigned int LOCKTIME_VERIFY_SEQUENCE = (1 << 0);
+/** Use GetMedianTimePast() instead of nTime for end point timestamp. */
+static constexpr unsigned int LOCKTIME_MEDIAN_TIME_PAST = (1 << 1);
+// }
 
-/** Default for -blockmaxweight, which controls the range of block weights the mining code will create **/
-static const unsigned int DEFAULT_BLOCK_MAX_WEIGHT = MAX_BLOCK_WEIGHT - 4000;
-/** Default for -blockmintxfee, which sets the minimum feerate for a transaction in blocks created by mining code **/
-static const unsigned int DEFAULT_BLOCK_MIN_TX_FEE = 1000;
-/** The maximum weight for transactions we're willing to relay/mine */
-static const unsigned int MAX_STANDARD_TX_WEIGHT = 400000;
-/** The minimum non-witness size for transactions we're willing to relay/mine (1 segwit input + 1 P2WPKH output = 82 bytes) */
-static const unsigned int MIN_STANDARD_TX_NONWITNESS_SIZE = 82;
-/** Maximum number of signature check operations in an IsStandard() P2SH script */
-static const unsigned int MAX_P2SH_SIGOPS = 15;
-/** The maximum number of sigops we're willing to relay/mine in a single tx */
-static const unsigned int MAX_STANDARD_TX_SIGOPS_COST = MAX_BLOCK_SIGOPS_COST/5;
-/** Default for -maxmempool, maximum megabytes of mempool memory usage */
-static const unsigned int DEFAULT_MAX_MEMPOOL_SIZE = 300;
-/** Default for -incrementalrelayfee, which sets the minimum feerate increase for mempool limiting or BIP 125 replacement **/
-static const unsigned int DEFAULT_INCREMENTAL_RELAY_FEE = 1000;
-/** Default for -bytespersigop */
-static const unsigned int DEFAULT_BYTES_PER_SIGOP = 20;
-/** Default for -permitbaremultisig */
-static const bool DEFAULT_PERMIT_BAREMULTISIG = true;
-/** The maximum number of witness stack items in a standard P2WSH script */
-static const unsigned int MAX_STANDARD_P2WSH_STACK_ITEMS = 100;
-/** The maximum size of each witness stack item in a standard P2WSH script */
-static const unsigned int MAX_STANDARD_P2WSH_STACK_ITEM_SIZE = 80;
-/** The maximum size of a standard witnessScript */
-static const unsigned int MAX_STANDARD_P2WSH_SCRIPT_SIZE = 3600;
-/** Min feerate for defining dust. Historically this has been based on the
- * minRelayTxFee, however changing the dust limit changes which transactions are
- * standard and should be done with care and ideally rarely. It makes sense to
- * only increase the dust limit after prior releases were already not creating
- * outputs below the new threshold */
-static const unsigned int DUST_RELAY_TX_FEE = 3000;
 /**
  * Standard script verification flags that standard transactions will comply
  * with. However scripts violating these flags may still be present in valid
@@ -77,42 +63,4 @@ static constexpr unsigned int STANDARD_NOT_MANDATORY_VERIFY_FLAGS = STANDARD_SCR
 static constexpr unsigned int STANDARD_LOCKTIME_VERIFY_FLAGS = LOCKTIME_VERIFY_SEQUENCE |
                                                                LOCKTIME_MEDIAN_TIME_PAST;
 
-CAmount GetDustThreshold(const CTxOut& txout, const CFeeRate& dustRelayFee);
-
-bool IsDust(const CTxOut& txout, const CFeeRate& dustRelayFee);
-
-bool IsStandard(const CScript& scriptPubKey, txnouttype& whichType);
-    /**
-     * Check for standard transaction types
-     * @return True if all outputs (scriptPubKeys) use only standard transaction forms
-     */
-bool IsStandardTx(const CTransaction& tx, bool permit_bare_multisig, const CFeeRate& dust_relay_fee, std::string& reason);
-    /**
-     * Check for standard transaction types
-     * @param[in] mapInputs    Map of previous transactions that have outputs we're spending
-     * @return True if all inputs (scriptSigs) use only standard transaction forms
-     */
-bool AreInputsStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs);
-    /**
-     * Check if the transaction is over standard P2WSH resources limit:
-     * 3600bytes witnessScript size, 80bytes per witness stack element, 100 witness stack elements
-     * These limits are adequate for multi-signature up to n-of-100 using OP_CHECKSIG, OP_ADD, and OP_EQUAL,
-     */
-bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs);
-
-/** Compute the virtual transaction size (weight reinterpreted as bytes). */
-int64_t GetVirtualTransactionSize(int64_t nWeight, int64_t nSigOpCost, unsigned int bytes_per_sigop);
-int64_t GetVirtualTransactionSize(const CTransaction& tx, int64_t nSigOpCost, unsigned int bytes_per_sigop);
-int64_t GetVirtualTransactionInputSize(const CTxIn& tx, int64_t nSigOpCost, unsigned int bytes_per_sigop);
-
-static inline int64_t GetVirtualTransactionSize(const CTransaction& tx)
-{
-    return GetVirtualTransactionSize(tx, 0, 0);
-}
-
-static inline int64_t GetVirtualTransactionInputSize(const CTxIn& tx)
-{
-    return GetVirtualTransactionInputSize(tx, 0, 0);
-}
-
 #endif // BITCOIN_POLICY_POLICY_H
diff --git a/script/interpreter.cpp b/script/interpreter.cpp
index 20fae2e..ebc9d1b 100644
--- a/script/interpreter.cpp
+++ b/script/interpreter.cpp
@@ -4,34 +4,18 @@
 // file COPYING or http://www.opensource.org/licenses/mit-license.php.
 
 #include <script/interpreter.h>
+#include <debugger/interpreter.h>
+
+#include <inttypes.h> // PRId64 ...
+#include <util/strencodings.h> // for Join<>
 
 #include <crypto/ripemd160.h>
 #include <crypto/sha1.h>
 #include <crypto/sha256.h>
 #include <pubkey.h>
-#include <script/script.h>
+#include <debugger/script.h>
 #include <uint256.h>
 
-typedef std::vector<unsigned char> valtype;
-
-namespace {
-
-inline bool set_success(ScriptError* ret)
-{
-    if (ret)
-        *ret = SCRIPT_ERR_OK;
-    return true;
-}
-
-inline bool set_error(ScriptError* ret, const ScriptError serror)
-{
-    if (ret)
-        *ret = serror;
-    return false;
-}
-
-} // namespace
-
 bool CastToBool(const valtype& vch)
 {
     for (unsigned int i = 0; i < vch.size(); i++)
@@ -53,12 +37,6 @@ bool CastToBool(const valtype& vch)
  */
 #define stacktop(i)  (stack.at(stack.size()+(i)))
 #define altstacktop(i)  (altstack.at(altstack.size()+(i)))
-static inline void popstack(std::vector<valtype>& stack)
-{
-    if (stack.empty())
-        throw std::runtime_error("popstack(): stack empty");
-    stack.pop_back();
-}
 
 bool static IsCompressedOrUncompressedPubKey(const valtype &vchPubKey) {
     if (vchPubKey.size() < CPubKey::COMPRESSED_PUBLIC_KEY_SIZE) {
@@ -278,7 +256,7 @@ int FindAndDelete(CScript& script, const CScript& b)
     return nFound;
 }
 
-bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror)
+bool StepScript(ScriptExecutionEnvironment& env, CScript::const_iterator& pc, CScript* local_script)
 {
     static const CScriptNum bnZero(0);
     static const CScriptNum bnOne(1);
@@ -288,788 +266,857 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&
     // static const valtype vchZero(0);
     static const valtype vchTrue(1, 1);
 
-    CScript::const_iterator pc = script.begin();
-    CScript::const_iterator pend = script.end();
-    CScript::const_iterator pbegincodehash = script.begin();
-    opcodetype opcode;
-    valtype vchPushValue;
-    std::vector<bool> vfExec;
-    std::vector<valtype> altstack;
-    set_error(serror, SCRIPT_ERR_UNKNOWN_ERROR);
-    if (script.size() > MAX_SCRIPT_SIZE)
-        return set_error(serror, SCRIPT_ERR_SCRIPT_SIZE);
-    int nOpCount = 0;
-    bool fRequireMinimal = (flags & SCRIPT_VERIFY_MINIMALDATA) != 0;
+    auto& pend = env.pend;
+    auto& pbegincodehash = env.pbegincodehash;
+    auto& opcode = env.opcode;
+    auto& vchPushValue = env.vchPushValue;
+    auto& vfExec = env.vfExec;
+    auto& altstack = env.altstack;
+    auto& nOpCount = env.nOpCount;
+    auto& fRequireMinimal = env.fRequireMinimal;
+    auto& stack = env.stack;
+    auto& script = local_script ? *local_script : env.script;
+    auto& flags = env.flags;
+    auto& checker = env.checker;
+    auto& sigversion = env.sigversion;
+    auto& serror = env.serror;
+    auto& pretend_valid_map = env.pretend_valid_map;
+    auto& pretend_valid_pubkeys = env.pretend_valid_pubkeys;
+
+    bool fExec = !count(vfExec.begin(), vfExec.end(), false);
 
-    try
+    //
+    // Read instruction
+    //
+    if (!script.GetOp(pc, opcode, vchPushValue))
+        return set_error(serror, SCRIPT_ERR_BAD_OPCODE);
+    if (vchPushValue.size() > MAX_SCRIPT_ELEMENT_SIZE)
+        return set_error(serror, SCRIPT_ERR_PUSH_SIZE);
+
+    // Note how OP_RESERVED does not count towards the opcode limit.
+    if (opcode > OP_16 && ++nOpCount > MAX_OPS_PER_SCRIPT)
+        return set_error(serror, SCRIPT_ERR_OP_COUNT);
+
+    if (opcode == OP_CAT ||
+        opcode == OP_SUBSTR ||
+        opcode == OP_LEFT ||
+        opcode == OP_RIGHT ||
+        opcode == OP_INVERT ||
+        opcode == OP_AND ||
+        opcode == OP_OR ||
+        opcode == OP_XOR ||
+        opcode == OP_2MUL ||
+        opcode == OP_2DIV ||
+        opcode == OP_MUL ||
+        opcode == OP_DIV ||
+        opcode == OP_MOD ||
+        opcode == OP_LSHIFT ||
+        opcode == OP_RSHIFT)
+        return set_error(serror, SCRIPT_ERR_DISABLED_OPCODE); // Disabled opcodes (CVE-2010-5137).
+
+    // With SCRIPT_VERIFY_CONST_SCRIPTCODE, OP_CODESEPARATOR in non-segwit script is rejected even in an unexecuted branch
+    if (opcode == OP_CODESEPARATOR && sigversion == SigVersion::BASE && (flags & SCRIPT_VERIFY_CONST_SCRIPTCODE))
+        return set_error(serror, SCRIPT_ERR_OP_CODESEPARATOR);
+
+    if (fExec && 0 <= opcode && opcode <= OP_PUSHDATA4) {
+        if (fRequireMinimal && !CheckMinimalPush(vchPushValue, opcode)) {
+            return set_error(serror, SCRIPT_ERR_MINIMALDATA);
+        }
+        pushstack(stack, vchPushValue);
+    } else if (fExec || (OP_IF <= opcode && opcode <= OP_ENDIF))
+    switch (opcode)
     {
-        while (pc < pend)
+        //
+        // Push value
+        //
+        case OP_1NEGATE:
+        case OP_1:
+        case OP_2:
+        case OP_3:
+        case OP_4:
+        case OP_5:
+        case OP_6:
+        case OP_7:
+        case OP_8:
+        case OP_9:
+        case OP_10:
+        case OP_11:
+        case OP_12:
+        case OP_13:
+        case OP_14:
+        case OP_15:
+        case OP_16:
+        {
+            // ( -- value)
+            CScriptNum bn((int)opcode - (int)(OP_1 - 1));
+            pushstack(stack, bn.getvch());
+            // The result of these opcodes should always be the minimal way to push the data
+            // they push, so no need for a CheckMinimalPush here.
+        }
+        break;
+
+
+        //
+        // Control
+        //
+        case OP_NOP:
+            break;
+
+        case OP_CHECKLOCKTIMEVERIFY:
         {
-            bool fExec = !count(vfExec.begin(), vfExec.end(), false);
+            if (!(flags & SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY)) {
+                // not enabled; treat as a NOP2
+                break;
+            }
 
+            if (stack.size() < 1)
+                return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
+
+            // Note that elsewhere numeric opcodes are limited to
+            // operands in the range -2**31+1 to 2**31-1, however it is
+            // legal for opcodes to produce results exceeding that
+            // range. This limitation is implemented by CScriptNum's
+            // default 4-byte limit.
             //
-            // Read instruction
+            // If we kept to that limit we'd have a year 2038 problem,
+            // even though the nLockTime field in transactions
+            // themselves is uint32 which only becomes meaningless
+            // after the year 2106.
             //
-            if (!script.GetOp(pc, opcode, vchPushValue))
-                return set_error(serror, SCRIPT_ERR_BAD_OPCODE);
-            if (vchPushValue.size() > MAX_SCRIPT_ELEMENT_SIZE)
-                return set_error(serror, SCRIPT_ERR_PUSH_SIZE);
+            // Thus as a special case we tell CScriptNum to accept up
+            // to 5-byte bignums, which are good until 2**39-1, well
+            // beyond the 2**32-1 limit of the nLockTime field itself.
+            const CScriptNum nLockTime(stacktop(-1), fRequireMinimal, 5);
+
+            // In the rare event that the argument may be < 0 due to
+            // some arithmetic being done first, you can always use
+            // 0 MAX CHECKLOCKTIMEVERIFY.
+            if (nLockTime < 0)
+                return set_error(serror, SCRIPT_ERR_NEGATIVE_LOCKTIME);
+
+            // Actually compare the specified lock time with the transaction.
+            if (!checker.CheckLockTime(nLockTime))
+                return set_error(serror, SCRIPT_ERR_UNSATISFIED_LOCKTIME);
+
+            break;
+        }
 
-            // Note how OP_RESERVED does not count towards the opcode limit.
-            if (opcode > OP_16 && ++nOpCount > MAX_OPS_PER_SCRIPT)
-                return set_error(serror, SCRIPT_ERR_OP_COUNT);
+        case OP_CHECKSEQUENCEVERIFY:
+        {
+            if (!(flags & SCRIPT_VERIFY_CHECKSEQUENCEVERIFY)) {
+                // not enabled; treat as a NOP3
+                break;
+            }
 
-            if (opcode == OP_CAT ||
-                opcode == OP_SUBSTR ||
-                opcode == OP_LEFT ||
-                opcode == OP_RIGHT ||
-                opcode == OP_INVERT ||
-                opcode == OP_AND ||
-                opcode == OP_OR ||
-                opcode == OP_XOR ||
-                opcode == OP_2MUL ||
-                opcode == OP_2DIV ||
-                opcode == OP_MUL ||
-                opcode == OP_DIV ||
-                opcode == OP_MOD ||
-                opcode == OP_LSHIFT ||
-                opcode == OP_RSHIFT)
-                return set_error(serror, SCRIPT_ERR_DISABLED_OPCODE); // Disabled opcodes (CVE-2010-5137).
-
-            // With SCRIPT_VERIFY_CONST_SCRIPTCODE, OP_CODESEPARATOR in non-segwit script is rejected even in an unexecuted branch
-            if (opcode == OP_CODESEPARATOR && sigversion == SigVersion::BASE && (flags & SCRIPT_VERIFY_CONST_SCRIPTCODE))
-                return set_error(serror, SCRIPT_ERR_OP_CODESEPARATOR);
-
-            if (fExec && 0 <= opcode && opcode <= OP_PUSHDATA4) {
-                if (fRequireMinimal && !CheckMinimalPush(vchPushValue, opcode)) {
-                    return set_error(serror, SCRIPT_ERR_MINIMALDATA);
-                }
-                stack.push_back(vchPushValue);
-            } else if (fExec || (OP_IF <= opcode && opcode <= OP_ENDIF))
-            switch (opcode)
-            {
-                //
-                // Push value
-                //
-                case OP_1NEGATE:
-                case OP_1:
-                case OP_2:
-                case OP_3:
-                case OP_4:
-                case OP_5:
-                case OP_6:
-                case OP_7:
-                case OP_8:
-                case OP_9:
-                case OP_10:
-                case OP_11:
-                case OP_12:
-                case OP_13:
-                case OP_14:
-                case OP_15:
-                case OP_16:
-                {
-                    // ( -- value)
-                    CScriptNum bn((int)opcode - (int)(OP_1 - 1));
-                    stack.push_back(bn.getvch());
-                    // The result of these opcodes should always be the minimal way to push the data
-                    // they push, so no need for a CheckMinimalPush here.
-                }
+            if (stack.size() < 1)
+                return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
+
+            // nSequence, like nLockTime, is a 32-bit unsigned integer
+            // field. See the comment in CHECKLOCKTIMEVERIFY regarding
+            // 5-byte numeric operands.
+            const CScriptNum nSequence(stacktop(-1), fRequireMinimal, 5);
+
+            // In the rare event that the argument may be < 0 due to
+            // some arithmetic being done first, you can always use
+            // 0 MAX CHECKSEQUENCEVERIFY.
+            if (nSequence < 0)
+                return set_error(serror, SCRIPT_ERR_NEGATIVE_LOCKTIME);
+
+            // To provide for future soft-fork extensibility, if the
+            // operand has the disabled lock-time flag set,
+            // CHECKSEQUENCEVERIFY behaves as a NOP.
+            if ((nSequence & CTxIn::SEQUENCE_LOCKTIME_DISABLE_FLAG) != 0)
                 break;
 
+            // Compare the specified sequence number with the input.
+            if (!checker.CheckSequence(nSequence))
+                return set_error(serror, SCRIPT_ERR_UNSATISFIED_LOCKTIME);
 
-                //
-                // Control
-                //
-                case OP_NOP:
-                    break;
+            break;
+        }
 
-                case OP_CHECKLOCKTIMEVERIFY:
-                {
-                    if (!(flags & SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY)) {
-                        // not enabled; treat as a NOP2
-                        break;
-                    }
+        case OP_NOP1: case OP_NOP4: case OP_NOP5:
+        case OP_NOP6: case OP_NOP7: case OP_NOP8: case OP_NOP9: case OP_NOP10:
+        {
+            if (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS)
+                return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS);
+        }
+        break;
 
-                    if (stack.size() < 1)
-                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
-
-                    // Note that elsewhere numeric opcodes are limited to
-                    // operands in the range -2**31+1 to 2**31-1, however it is
-                    // legal for opcodes to produce results exceeding that
-                    // range. This limitation is implemented by CScriptNum's
-                    // default 4-byte limit.
-                    //
-                    // If we kept to that limit we'd have a year 2038 problem,
-                    // even though the nLockTime field in transactions
-                    // themselves is uint32 which only becomes meaningless
-                    // after the year 2106.
-                    //
-                    // Thus as a special case we tell CScriptNum to accept up
-                    // to 5-byte bignums, which are good until 2**39-1, well
-                    // beyond the 2**32-1 limit of the nLockTime field itself.
-                    const CScriptNum nLockTime(stacktop(-1), fRequireMinimal, 5);
-
-                    // In the rare event that the argument may be < 0 due to
-                    // some arithmetic being done first, you can always use
-                    // 0 MAX CHECKLOCKTIMEVERIFY.
-                    if (nLockTime < 0)
-                        return set_error(serror, SCRIPT_ERR_NEGATIVE_LOCKTIME);
-
-                    // Actually compare the specified lock time with the transaction.
-                    if (!checker.CheckLockTime(nLockTime))
-                        return set_error(serror, SCRIPT_ERR_UNSATISFIED_LOCKTIME);
-
-                    break;
+        case OP_IF:
+        case OP_NOTIF:
+        {
+            // <expression> if [statements] [else [statements]] endif
+            bool fValue = false;
+            if (fExec)
+            {
+                if (stack.size() < 1)
+                    return set_error(serror, SCRIPT_ERR_UNBALANCED_CONDITIONAL);
+                valtype& vch = stacktop(-1);
+                if (sigversion == SigVersion::WITNESS_V0 && (flags & SCRIPT_VERIFY_MINIMALIF)) {
+                    if (vch.size() > 1)
+                        return set_error(serror, SCRIPT_ERR_MINIMALIF);
+                    if (vch.size() == 1 && vch[0] != 1)
+                        return set_error(serror, SCRIPT_ERR_MINIMALIF);
                 }
+                fValue = CastToBool(vch);
+                if (opcode == OP_NOTIF)
+                    fValue = !fValue;
+                popstack(stack);
+            }
+            vfExec.push_back(fValue);
+        }
+        break;
 
-                case OP_CHECKSEQUENCEVERIFY:
-                {
-                    if (!(flags & SCRIPT_VERIFY_CHECKSEQUENCEVERIFY)) {
-                        // not enabled; treat as a NOP3
-                        break;
-                    }
+        case OP_ELSE:
+        {
+            if (vfExec.empty())
+                return set_error(serror, SCRIPT_ERR_UNBALANCED_CONDITIONAL);
+            vfExec.back() = !vfExec.back();
+        }
+        break;
 
-                    if (stack.size() < 1)
-                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
+        case OP_ENDIF:
+        {
+            if (vfExec.empty())
+                return set_error(serror, SCRIPT_ERR_UNBALANCED_CONDITIONAL);
+            vfExec.pop_back();
+        }
+        break;
 
-                    // nSequence, like nLockTime, is a 32-bit unsigned integer
-                    // field. See the comment in CHECKLOCKTIMEVERIFY regarding
-                    // 5-byte numeric operands.
-                    const CScriptNum nSequence(stacktop(-1), fRequireMinimal, 5);
+        case OP_VERIFY:
+        {
+            // (true -- ) or
+            // (false -- false) and return
+            if (stack.size() < 1)
+                return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
+            bool fValue = CastToBool(stacktop(-1));
+            if (fValue)
+                popstack(stack);
+            else
+                return set_error(serror, SCRIPT_ERR_VERIFY);
+        }
+        break;
 
-                    // In the rare event that the argument may be < 0 due to
-                    // some arithmetic being done first, you can always use
-                    // 0 MAX CHECKSEQUENCEVERIFY.
-                    if (nSequence < 0)
-                        return set_error(serror, SCRIPT_ERR_NEGATIVE_LOCKTIME);
+        case OP_RETURN:
+        {
+            return set_error(serror, SCRIPT_ERR_OP_RETURN);
+        }
+        break;
 
-                    // To provide for future soft-fork extensibility, if the
-                    // operand has the disabled lock-time flag set,
-                    // CHECKSEQUENCEVERIFY behaves as a NOP.
-                    if ((nSequence & CTxIn::SEQUENCE_LOCKTIME_DISABLE_FLAG) != 0)
-                        break;
 
-                    // Compare the specified sequence number with the input.
-                    if (!checker.CheckSequence(nSequence))
-                        return set_error(serror, SCRIPT_ERR_UNSATISFIED_LOCKTIME);
+        //
+        // Stack ops
+        //
+        case OP_TOALTSTACK:
+        {
+            if (stack.size() < 1)
+                return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
+            pushstack(altstack, stacktop(-1));
+            popstack(stack);
+        }
+        break;
 
-                    break;
-                }
+        case OP_FROMALTSTACK:
+        {
+            if (altstack.size() < 1)
+                return set_error(serror, SCRIPT_ERR_INVALID_ALTSTACK_OPERATION);
+            pushstack(stack, altstacktop(-1));
+            popstack(altstack);
+        }
+        break;
 
-                case OP_NOP1: case OP_NOP4: case OP_NOP5:
-                case OP_NOP6: case OP_NOP7: case OP_NOP8: case OP_NOP9: case OP_NOP10:
-                {
-                    if (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS)
-                        return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS);
-                }
-                break;
+        case OP_2DROP:
+        {
+            // (x1 x2 -- )
+            if (stack.size() < 2)
+                return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
+            popstack(stack);
+            popstack(stack);
+        }
+        break;
 
-                case OP_IF:
-                case OP_NOTIF:
-                {
-                    // <expression> if [statements] [else [statements]] endif
-                    bool fValue = false;
-                    if (fExec)
-                    {
-                        if (stack.size() < 1)
-                            return set_error(serror, SCRIPT_ERR_UNBALANCED_CONDITIONAL);
-                        valtype& vch = stacktop(-1);
-                        if (sigversion == SigVersion::WITNESS_V0 && (flags & SCRIPT_VERIFY_MINIMALIF)) {
-                            if (vch.size() > 1)
-                                return set_error(serror, SCRIPT_ERR_MINIMALIF);
-                            if (vch.size() == 1 && vch[0] != 1)
-                                return set_error(serror, SCRIPT_ERR_MINIMALIF);
-                        }
-                        fValue = CastToBool(vch);
-                        if (opcode == OP_NOTIF)
-                            fValue = !fValue;
-                        popstack(stack);
-                    }
-                    vfExec.push_back(fValue);
-                }
-                break;
+        case OP_2DUP:
+        {
+            // (x1 x2 -- x1 x2 x1 x2)
+            if (stack.size() < 2)
+                return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
+            valtype vch1 = stacktop(-2);
+            valtype vch2 = stacktop(-1);
+            pushstack(stack, vch1);
+            pushstack(stack, vch2);
+        }
+        break;
 
-                case OP_ELSE:
-                {
-                    if (vfExec.empty())
-                        return set_error(serror, SCRIPT_ERR_UNBALANCED_CONDITIONAL);
-                    vfExec.back() = !vfExec.back();
-                }
-                break;
+        case OP_3DUP:
+        {
+            // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)
+            if (stack.size() < 3)
+                return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
+            valtype vch1 = stacktop(-3);
+            valtype vch2 = stacktop(-2);
+            valtype vch3 = stacktop(-1);
+            pushstack(stack, vch1);
+            pushstack(stack, vch2);
+            pushstack(stack, vch3);
+        }
+        break;
 
-                case OP_ENDIF:
-                {
-                    if (vfExec.empty())
-                        return set_error(serror, SCRIPT_ERR_UNBALANCED_CONDITIONAL);
-                    vfExec.pop_back();
-                }
-                break;
+        case OP_2OVER:
+        {
+            // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)
+            if (stack.size() < 4)
+                return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
+            valtype vch1 = stacktop(-4);
+            valtype vch2 = stacktop(-3);
+            pushstack(stack, vch1);
+            pushstack(stack, vch2);
+        }
+        break;
 
-                case OP_VERIFY:
-                {
-                    // (true -- ) or
-                    // (false -- false) and return
-                    if (stack.size() < 1)
-                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
-                    bool fValue = CastToBool(stacktop(-1));
-                    if (fValue)
-                        popstack(stack);
-                    else
-                        return set_error(serror, SCRIPT_ERR_VERIFY);
-                }
-                break;
+        case OP_2ROT:
+        {
+            // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)
+            if (stack.size() < 6)
+                return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
+            valtype vch1 = stacktop(-6);
+            valtype vch2 = stacktop(-5);
+            stack.erase(stack.end()-6, stack.end()-4);
+            pushstack(stack, vch1);
+            pushstack(stack, vch2);
+        }
+        break;
 
-                case OP_RETURN:
-                {
-                    return set_error(serror, SCRIPT_ERR_OP_RETURN);
-                }
-                break;
+        case OP_2SWAP:
+        {
+            // (x1 x2 x3 x4 -- x3 x4 x1 x2)
+            if (stack.size() < 4)
+                return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
+            swap(stacktop(-4), stacktop(-2));
+            swap(stacktop(-3), stacktop(-1));
+        }
+        break;
 
+        case OP_IFDUP:
+        {
+            // (x - 0 | x x)
+            if (stack.size() < 1)
+                return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
+            valtype vch = stacktop(-1);
+            if (CastToBool(vch))
+                pushstack(stack, vch);
+        }
+        break;
 
-                //
-                // Stack ops
-                //
-                case OP_TOALTSTACK:
-                {
-                    if (stack.size() < 1)
-                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
-                    altstack.push_back(stacktop(-1));
-                    popstack(stack);
-                }
-                break;
+        case OP_DEPTH:
+        {
+            // -- stacksize
+            CScriptNum bn(stack.size());
+            pushstack(stack, bn.getvch());
+        }
+        break;
 
-                case OP_FROMALTSTACK:
-                {
-                    if (altstack.size() < 1)
-                        return set_error(serror, SCRIPT_ERR_INVALID_ALTSTACK_OPERATION);
-                    stack.push_back(altstacktop(-1));
-                    popstack(altstack);
-                }
-                break;
+        case OP_DROP:
+        {
+            // (x -- )
+            if (stack.size() < 1)
+                return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
+            popstack(stack);
+        }
+        break;
 
-                case OP_2DROP:
-                {
-                    // (x1 x2 -- )
-                    if (stack.size() < 2)
-                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
-                    popstack(stack);
-                    popstack(stack);
-                }
-                break;
+        case OP_DUP:
+        {
+            // (x -- x x)
+            if (stack.size() < 1)
+                return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
+            valtype vch = stacktop(-1);
+            pushstack(stack, vch);
+        }
+        break;
 
-                case OP_2DUP:
-                {
-                    // (x1 x2 -- x1 x2 x1 x2)
-                    if (stack.size() < 2)
-                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
-                    valtype vch1 = stacktop(-2);
-                    valtype vch2 = stacktop(-1);
-                    stack.push_back(vch1);
-                    stack.push_back(vch2);
-                }
-                break;
+        case OP_NIP:
+        {
+            // (x1 x2 -- x2)
+            if (stack.size() < 2)
+                return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
+            stack.erase(stack.end() - 2);
+        }
+        break;
 
-                case OP_3DUP:
-                {
-                    // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)
-                    if (stack.size() < 3)
-                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
-                    valtype vch1 = stacktop(-3);
-                    valtype vch2 = stacktop(-2);
-                    valtype vch3 = stacktop(-1);
-                    stack.push_back(vch1);
-                    stack.push_back(vch2);
-                    stack.push_back(vch3);
-                }
-                break;
+        case OP_OVER:
+        {
+            // (x1 x2 -- x1 x2 x1)
+            if (stack.size() < 2)
+                return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
+            valtype vch = stacktop(-2);
+            pushstack(stack, vch);
+        }
+        break;
 
-                case OP_2OVER:
-                {
-                    // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)
-                    if (stack.size() < 4)
-                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
-                    valtype vch1 = stacktop(-4);
-                    valtype vch2 = stacktop(-3);
-                    stack.push_back(vch1);
-                    stack.push_back(vch2);
-                }
-                break;
+        case OP_PICK:
+        case OP_ROLL:
+        {
+            // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)
+            // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)
+            if (stack.size() < 2)
+                return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
+            int n = CScriptNum(stacktop(-1), fRequireMinimal).getint();
+            popstack(stack);
+            if (n < 0 || n >= (int)stack.size())
+                return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
+            valtype vch = stacktop(-n-1);
+            if (opcode == OP_ROLL)
+                stack.erase(stack.end()-n-1);
+            pushstack(stack, vch);
+        }
+        break;
 
-                case OP_2ROT:
-                {
-                    // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)
-                    if (stack.size() < 6)
-                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
-                    valtype vch1 = stacktop(-6);
-                    valtype vch2 = stacktop(-5);
-                    stack.erase(stack.end()-6, stack.end()-4);
-                    stack.push_back(vch1);
-                    stack.push_back(vch2);
-                }
-                break;
+        case OP_ROT:
+        {
+            // (x1 x2 x3 -- x2 x3 x1)
+            //  x2 x1 x3  after first swap
+            //  x2 x3 x1  after second swap
+            if (stack.size() < 3)
+                return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
+            swap(stacktop(-3), stacktop(-2));
+            swap(stacktop(-2), stacktop(-1));
+        }
+        break;
 
-                case OP_2SWAP:
-                {
-                    // (x1 x2 x3 x4 -- x3 x4 x1 x2)
-                    if (stack.size() < 4)
-                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
-                    swap(stacktop(-4), stacktop(-2));
-                    swap(stacktop(-3), stacktop(-1));
-                }
-                break;
+        case OP_SWAP:
+        {
+            // (x1 x2 -- x2 x1)
+            if (stack.size() < 2)
+                return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
+            swap(stacktop(-2), stacktop(-1));
+        }
+        break;
 
-                case OP_IFDUP:
-                {
-                    // (x - 0 | x x)
-                    if (stack.size() < 1)
-                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
-                    valtype vch = stacktop(-1);
-                    if (CastToBool(vch))
-                        stack.push_back(vch);
-                }
-                break;
+        case OP_TUCK:
+        {
+            // (x1 x2 -- x2 x1 x2)
+            if (stack.size() < 2)
+                return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
+            valtype vch = stacktop(-1);
+            stack.insert(stack.end()-2, vch);
+        }
+        break;
 
-                case OP_DEPTH:
-                {
-                    // -- stacksize
-                    CScriptNum bn(stack.size());
-                    stack.push_back(bn.getvch());
-                }
-                break;
 
-                case OP_DROP:
-                {
-                    // (x -- )
-                    if (stack.size() < 1)
-                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
-                    popstack(stack);
-                }
-                break;
+        case OP_SIZE:
+        {
+            // (in -- in size)
+            if (stack.size() < 1)
+                return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
+            CScriptNum bn(stacktop(-1).size());
+            pushstack(stack, bn.getvch());
+        }
+        break;
 
-                case OP_DUP:
-                {
-                    // (x -- x x)
-                    if (stack.size() < 1)
-                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
-                    valtype vch = stacktop(-1);
-                    stack.push_back(vch);
-                }
-                break;
 
-                case OP_NIP:
-                {
-                    // (x1 x2 -- x2)
-                    if (stack.size() < 2)
-                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
-                    stack.erase(stack.end() - 2);
-                }
+        //
+        // Bitwise logic
+        //
+        case OP_EQUAL:
+        case OP_EQUALVERIFY:
+        //case OP_NOTEQUAL: // use OP_NUMNOTEQUAL
+        {
+            // (x1 x2 - bool)
+            if (stack.size() < 2)
+                return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
+            valtype& vch1 = stacktop(-2);
+            valtype& vch2 = stacktop(-1);
+            bool fEqual = (vch1 == vch2);
+            // OP_NOTEQUAL is disabled because it would be too easy to say
+            // something like n != 1 and have some wiseguy pass in 1 with extra
+            // zero bytes after it (numerically, 0x01 == 0x0001 == 0x000001)
+            //if (opcode == OP_NOTEQUAL)
+            //    fEqual = !fEqual;
+            popstack(stack);
+            popstack(stack);
+            pushstack(stack, fEqual ? vchTrue : vchFalse);
+            if (opcode == OP_EQUALVERIFY)
+            {
+                if (fEqual)
+                    popstack(stack);
+                else
+                    return set_error(serror, SCRIPT_ERR_EQUALVERIFY);
+            }
+        }
+        break;
+
+
+        //
+        // Numeric
+        //
+        case OP_1ADD:
+        case OP_1SUB:
+        case OP_NEGATE:
+        case OP_ABS:
+        case OP_NOT:
+        case OP_0NOTEQUAL:
+        {
+            // (in -- out)
+            if (stack.size() < 1)
+                return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
+            CScriptNum bn(stacktop(-1), fRequireMinimal);
+            switch (opcode)
+            {
+            case OP_1ADD:       bn += bnOne; break;
+            case OP_1SUB:       bn -= bnOne; break;
+            case OP_NEGATE:     bn = -bn; break;
+            case OP_ABS:        if (bn < bnZero) bn = -bn; break;
+            case OP_NOT:        bn = (bn == bnZero); break;
+            case OP_0NOTEQUAL:  bn = (bn != bnZero); break;
+            default:            assert(!"invalid opcode"); break;
+            }
+            popstack(stack);
+            pushstack(stack, bn.getvch());
+        }
+        break;
+
+        case OP_ADD:
+        case OP_SUB:
+        case OP_BOOLAND:
+        case OP_BOOLOR:
+        case OP_NUMEQUAL:
+        case OP_NUMEQUALVERIFY:
+        case OP_NUMNOTEQUAL:
+        case OP_LESSTHAN:
+        case OP_GREATERTHAN:
+        case OP_LESSTHANOREQUAL:
+        case OP_GREATERTHANOREQUAL:
+        case OP_MIN:
+        case OP_MAX:
+        {
+            // (x1 x2 -- out)
+            if (stack.size() < 2)
+                return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
+            CScriptNum bn1(stacktop(-2), fRequireMinimal);
+            CScriptNum bn2(stacktop(-1), fRequireMinimal);
+            CScriptNum bn(0);
+            switch (opcode)
+            {
+            case OP_ADD:
+                bn = bn1 + bn2;
                 break;
 
-                case OP_OVER:
-                {
-                    // (x1 x2 -- x1 x2 x1)
-                    if (stack.size() < 2)
-                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
-                    valtype vch = stacktop(-2);
-                    stack.push_back(vch);
-                }
+            case OP_SUB:
+                bn = bn1 - bn2;
                 break;
 
-                case OP_PICK:
-                case OP_ROLL:
-                {
-                    // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)
-                    // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)
-                    if (stack.size() < 2)
-                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
-                    int n = CScriptNum(stacktop(-1), fRequireMinimal).getint();
+            case OP_BOOLAND:             bn = (bn1 != bnZero && bn2 != bnZero); break;
+            case OP_BOOLOR:              bn = (bn1 != bnZero || bn2 != bnZero); break;
+            case OP_NUMEQUAL:            bn = (bn1 == bn2); break;
+            case OP_NUMEQUALVERIFY:      bn = (bn1 == bn2); break;
+            case OP_NUMNOTEQUAL:         bn = (bn1 != bn2); break;
+            case OP_LESSTHAN:            bn = (bn1 < bn2); break;
+            case OP_GREATERTHAN:         bn = (bn1 > bn2); break;
+            case OP_LESSTHANOREQUAL:     bn = (bn1 <= bn2); break;
+            case OP_GREATERTHANOREQUAL:  bn = (bn1 >= bn2); break;
+            case OP_MIN:                 bn = (bn1 < bn2 ? bn1 : bn2); break;
+            case OP_MAX:                 bn = (bn1 > bn2 ? bn1 : bn2); break;
+            default:                     assert(!"invalid opcode"); break;
+            }
+            popstack(stack);
+            popstack(stack);
+            pushstack(stack, bn.getvch());
+
+            if (opcode == OP_NUMEQUALVERIFY)
+            {
+                if (CastToBool(stacktop(-1)))
                     popstack(stack);
-                    if (n < 0 || n >= (int)stack.size())
-                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
-                    valtype vch = stacktop(-n-1);
-                    if (opcode == OP_ROLL)
-                        stack.erase(stack.end()-n-1);
-                    stack.push_back(vch);
-                }
-                break;
+                else
+                    return set_error(serror, SCRIPT_ERR_NUMEQUALVERIFY);
+            }
+        }
+        break;
 
-                case OP_ROT:
-                {
-                    // (x1 x2 x3 -- x2 x3 x1)
-                    //  x2 x1 x3  after first swap
-                    //  x2 x3 x1  after second swap
-                    if (stack.size() < 3)
-                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
-                    swap(stacktop(-3), stacktop(-2));
-                    swap(stacktop(-2), stacktop(-1));
-                }
-                break;
+        case OP_WITHIN:
+        {
+            // (x min max -- out)
+            if (stack.size() < 3)
+                return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
+            CScriptNum bn1(stacktop(-3), fRequireMinimal);
+            CScriptNum bn2(stacktop(-2), fRequireMinimal);
+            CScriptNum bn3(stacktop(-1), fRequireMinimal);
+            bool fValue = (bn2 <= bn1 && bn1 < bn3);
+            popstack(stack);
+            popstack(stack);
+            popstack(stack);
+            pushstack(stack, fValue ? vchTrue : vchFalse);
+        }
+        break;
 
-                case OP_SWAP:
-                {
-                    // (x1 x2 -- x2 x1)
-                    if (stack.size() < 2)
-                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
-                    swap(stacktop(-2), stacktop(-1));
-                }
-                break;
 
-                case OP_TUCK:
-                {
-                    // (x1 x2 -- x2 x1 x2)
-                    if (stack.size() < 2)
-                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
-                    valtype vch = stacktop(-1);
-                    stack.insert(stack.end()-2, vch);
-                }
-                break;
+        //
+        // Crypto
+        //
+        case OP_RIPEMD160:
+        case OP_SHA1:
+        case OP_SHA256:
+        case OP_HASH160:
+        case OP_HASH256:
+        {
+            // (in -- hash)
+            if (stack.size() < 1)
+                return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
+            valtype& vch = stacktop(-1);
+            valtype vchHash((opcode == OP_RIPEMD160 || opcode == OP_SHA1 || opcode == OP_HASH160) ? 20 : 32);
+            if (opcode == OP_RIPEMD160)
+                CRIPEMD160().Write(vch.data(), vch.size()).Finalize(vchHash.data());
+            else if (opcode == OP_SHA1)
+                CSHA1().Write(vch.data(), vch.size()).Finalize(vchHash.data());
+            else if (opcode == OP_SHA256)
+                CSHA256().Write(vch.data(), vch.size()).Finalize(vchHash.data());
+            else if (opcode == OP_HASH160)
+                CHash160().Write(vch.data(), vch.size()).Finalize(vchHash.data());
+            else if (opcode == OP_HASH256)
+                CHash256().Write(vch.data(), vch.size()).Finalize(vchHash.data());
+            popstack(stack);
+            pushstack(stack, vchHash);
+        }
+        break;
 
+        case OP_CODESEPARATOR:
+        {
+            // If SCRIPT_VERIFY_CONST_SCRIPTCODE flag is set, use of OP_CODESEPARATOR is rejected in pre-segwit
+            // script, even in an unexecuted branch (this is checked above the opcode case statement).
 
-                case OP_SIZE:
-                {
-                    // (in -- in size)
-                    if (stack.size() < 1)
-                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
-                    CScriptNum bn(stacktop(-1).size());
-                    stack.push_back(bn.getvch());
-                }
-                break;
+            // Hash starts after the code separator
+            pbegincodehash = pc;
+        }
+        break;
 
+        case OP_CHECKSIG:
+        case OP_CHECKSIGVERIFY:
+        {
+            // (sig pubkey -- bool)
+            if (stack.size() < 2)
+                return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
 
-                //
-                // Bitwise logic
-                //
-                case OP_EQUAL:
-                case OP_EQUALVERIFY:
-                //case OP_NOTEQUAL: // use OP_NUMNOTEQUAL
-                {
-                    // (x1 x2 - bool)
-                    if (stack.size() < 2)
-                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
-                    valtype& vch1 = stacktop(-2);
-                    valtype& vch2 = stacktop(-1);
-                    bool fEqual = (vch1 == vch2);
-                    // OP_NOTEQUAL is disabled because it would be too easy to say
-                    // something like n != 1 and have some wiseguy pass in 1 with extra
-                    // zero bytes after it (numerically, 0x01 == 0x0001 == 0x000001)
-                    //if (opcode == OP_NOTEQUAL)
-                    //    fEqual = !fEqual;
-                    popstack(stack);
-                    popstack(stack);
-                    stack.push_back(fEqual ? vchTrue : vchFalse);
-                    if (opcode == OP_EQUALVERIFY)
-                    {
-                        if (fEqual)
-                            popstack(stack);
-                        else
-                            return set_error(serror, SCRIPT_ERR_EQUALVERIFY);
-                    }
-                }
-                break;
+            valtype& vchSig    = stacktop(-2);
+            valtype& vchPubKey = stacktop(-1);
 
+            // Subset of script starting at the most recent codeseparator
+            CScript scriptCode(pbegincodehash, pend);
 
-                //
-                // Numeric
-                //
-                case OP_1ADD:
-                case OP_1SUB:
-                case OP_NEGATE:
-                case OP_ABS:
-                case OP_NOT:
-                case OP_0NOTEQUAL:
-                {
-                    // (in -- out)
-                    if (stack.size() < 1)
-                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
-                    CScriptNum bn(stacktop(-1), fRequireMinimal);
-                    switch (opcode)
-                    {
-                    case OP_1ADD:       bn += bnOne; break;
-                    case OP_1SUB:       bn -= bnOne; break;
-                    case OP_NEGATE:     bn = -bn; break;
-                    case OP_ABS:        if (bn < bnZero) bn = -bn; break;
-                    case OP_NOT:        bn = (bn == bnZero); break;
-                    case OP_0NOTEQUAL:  bn = (bn != bnZero); break;
-                    default:            assert(!"invalid opcode"); break;
-                    }
-                    popstack(stack);
-                    stack.push_back(bn.getvch());
-                }
-                break;
+            // Drop the signature in pre-segwit scripts but not segwit scripts
+            if (sigversion == SigVersion::BASE) {
+                int found = FindAndDelete(scriptCode, CScript() << vchSig);
+                if (found > 0 && (flags & SCRIPT_VERIFY_CONST_SCRIPTCODE))
+                    return set_error(serror, SCRIPT_ERR_SIG_FINDANDDELETE);
+            }
 
-                case OP_ADD:
-                case OP_SUB:
-                case OP_BOOLAND:
-                case OP_BOOLOR:
-                case OP_NUMEQUAL:
-                case OP_NUMEQUALVERIFY:
-                case OP_NUMNOTEQUAL:
-                case OP_LESSTHAN:
-                case OP_GREATERTHAN:
-                case OP_LESSTHANOREQUAL:
-                case OP_GREATERTHANOREQUAL:
-                case OP_MIN:
-                case OP_MAX:
-                {
-                    // (x1 x2 -- out)
-                    if (stack.size() < 2)
-                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
-                    CScriptNum bn1(stacktop(-2), fRequireMinimal);
-                    CScriptNum bn2(stacktop(-1), fRequireMinimal);
-                    CScriptNum bn(0);
-                    switch (opcode)
-                    {
-                    case OP_ADD:
-                        bn = bn1 + bn2;
-                        break;
-
-                    case OP_SUB:
-                        bn = bn1 - bn2;
-                        break;
-
-                    case OP_BOOLAND:             bn = (bn1 != bnZero && bn2 != bnZero); break;
-                    case OP_BOOLOR:              bn = (bn1 != bnZero || bn2 != bnZero); break;
-                    case OP_NUMEQUAL:            bn = (bn1 == bn2); break;
-                    case OP_NUMEQUALVERIFY:      bn = (bn1 == bn2); break;
-                    case OP_NUMNOTEQUAL:         bn = (bn1 != bn2); break;
-                    case OP_LESSTHAN:            bn = (bn1 < bn2); break;
-                    case OP_GREATERTHAN:         bn = (bn1 > bn2); break;
-                    case OP_LESSTHANOREQUAL:     bn = (bn1 <= bn2); break;
-                    case OP_GREATERTHANOREQUAL:  bn = (bn1 >= bn2); break;
-                    case OP_MIN:                 bn = (bn1 < bn2 ? bn1 : bn2); break;
-                    case OP_MAX:                 bn = (bn1 > bn2 ? bn1 : bn2); break;
-                    default:                     assert(!"invalid opcode"); break;
-                    }
-                    popstack(stack);
-                    popstack(stack);
-                    stack.push_back(bn.getvch());
-
-                    if (opcode == OP_NUMEQUALVERIFY)
-                    {
-                        if (CastToBool(stacktop(-1)))
-                            popstack(stack);
-                        else
-                            return set_error(serror, SCRIPT_ERR_NUMEQUALVERIFY);
+            bool fSuccess;
+            std::string sig_str = HexStr(vchSig);
+            std::string pub_str = HexStr(vchPubKey);
+            if (pretend_valid_pubkeys.count(vchPubKey)) {
+                fSuccess = pretend_valid_map.count(vchSig) && pretend_valid_map.at(vchSig) == vchPubKey;
+                if (!fSuccess) {
+                    fprintf(stderr, "note: pretend signature mismatch: got %s=%s, expected %s=%s\n",
+                        sig_str.c_str(), pub_str.c_str(),
+                        pretend_valid_map.count(vchSig) ? HexStr(pretend_valid_map.at(vchSig)).c_str() : "<null>",
+                        pub_str.c_str()
+                    );
+                }
+            } else {
+                if (!CheckSignatureEncoding(vchSig, flags, serror) || !CheckPubKeyEncoding(vchPubKey, flags, sigversion, serror)) {
+                    //serror is set
+                    if (pretend_valid_map.size() > 0) {
+                        fprintf(stderr, "note: pubkey not found in pretend set: %s not in (%s)\n", pub_str.c_str(), Join<std::set<valtype>,std::vector<unsigned char>>(pretend_valid_pubkeys, ", ", JoinHexStrFun).c_str());
                     }
+                    return false;
                 }
-                break;
-
-                case OP_WITHIN:
-                {
-                    // (x min max -- out)
-                    if (stack.size() < 3)
-                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
-                    CScriptNum bn1(stacktop(-3), fRequireMinimal);
-                    CScriptNum bn2(stacktop(-2), fRequireMinimal);
-                    CScriptNum bn3(stacktop(-1), fRequireMinimal);
-                    bool fValue = (bn2 <= bn1 && bn1 < bn3);
-                    popstack(stack);
-                    popstack(stack);
-                    popstack(stack);
-                    stack.push_back(fValue ? vchTrue : vchFalse);
+                fSuccess = checker.CheckSig(vchSig, vchPubKey, scriptCode, sigversion);
+                if (!fSuccess && pretend_valid_map.size() > 0) {
+                    fprintf(stderr, "note: pubkey not found in pretend set: %s not in (%s)\n", pub_str.c_str(), Join<std::set<valtype>,std::vector<unsigned char>>(pretend_valid_pubkeys, ", ", JoinHexStrFun).c_str());
                 }
-                break;
+            }
 
+            if (!fSuccess && (flags & SCRIPT_VERIFY_NULLFAIL) && vchSig.size())
+                return set_error(serror, SCRIPT_ERR_SIG_NULLFAIL);
 
-                //
-                // Crypto
-                //
-                case OP_RIPEMD160:
-                case OP_SHA1:
-                case OP_SHA256:
-                case OP_HASH160:
-                case OP_HASH256:
-                {
-                    // (in -- hash)
-                    if (stack.size() < 1)
-                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
-                    valtype& vch = stacktop(-1);
-                    valtype vchHash((opcode == OP_RIPEMD160 || opcode == OP_SHA1 || opcode == OP_HASH160) ? 20 : 32);
-                    if (opcode == OP_RIPEMD160)
-                        CRIPEMD160().Write(vch.data(), vch.size()).Finalize(vchHash.data());
-                    else if (opcode == OP_SHA1)
-                        CSHA1().Write(vch.data(), vch.size()).Finalize(vchHash.data());
-                    else if (opcode == OP_SHA256)
-                        CSHA256().Write(vch.data(), vch.size()).Finalize(vchHash.data());
-                    else if (opcode == OP_HASH160)
-                        CHash160().Write(vch.data(), vch.size()).Finalize(vchHash.data());
-                    else if (opcode == OP_HASH256)
-                        CHash256().Write(vch.data(), vch.size()).Finalize(vchHash.data());
+            popstack(stack);
+            popstack(stack);
+            pushstack(stack, fSuccess ? vchTrue : vchFalse);
+            if (opcode == OP_CHECKSIGVERIFY)
+            {
+                if (fSuccess)
                     popstack(stack);
-                    stack.push_back(vchHash);
-                }
-                break;
-
-                case OP_CODESEPARATOR:
-                {
-                    // If SCRIPT_VERIFY_CONST_SCRIPTCODE flag is set, use of OP_CODESEPARATOR is rejected in pre-segwit
-                    // script, even in an unexecuted branch (this is checked above the opcode case statement).
+                else
+                    return set_error(serror, SCRIPT_ERR_CHECKSIGVERIFY);
+            }
+        }
+        break;
 
-                    // Hash starts after the code separator
-                    pbegincodehash = pc;
+        case OP_CHECKMULTISIG:
+        case OP_CHECKMULTISIGVERIFY:
+        {
+            // ([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)
+
+            int i = 1;
+            btc_sign_logf("stack has %zu entries [require 1]\n", stack.size());
+            if ((int)stack.size() < i)
+                return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
+
+            int nKeysCount = CScriptNum(stacktop(-i), fRequireMinimal).getint();
+            if (nKeysCount < 0 || nKeysCount > MAX_PUBKEYS_PER_MULTISIG)
+                return set_error(serror, SCRIPT_ERR_PUBKEY_COUNT);
+            nOpCount += nKeysCount;
+            if (nOpCount > MAX_OPS_PER_SCRIPT)
+                return set_error(serror, SCRIPT_ERR_OP_COUNT);
+            int ikey = ++i;
+            // ikey2 is the position of last non-signature item in the stack. Top stack item = 1.
+            // With SCRIPT_VERIFY_NULLFAIL, this is used for cleanup if operation fails.
+            int ikey2 = nKeysCount + 2;
+            i += nKeysCount;
+            btc_sign_logf("stack has %zu entries [require %d]\n", stack.size(), i);
+            if ((int)stack.size() < i)
+                return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
+
+            int nSigsCount = CScriptNum(stacktop(-i), fRequireMinimal).getint();
+            if (nSigsCount < 0 || nSigsCount > nKeysCount)
+                return set_error(serror, SCRIPT_ERR_SIG_COUNT);
+            int isig = ++i;
+            i += nSigsCount;
+            btc_sign_logf("stack has %zu entries [require %d]\n", stack.size(), i);
+            if ((int)stack.size() < i)
+                return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
+
+            // Subset of script starting at the most recent codeseparator
+            CScript scriptCode(pbegincodehash, pend);
+
+            // Drop the signature in pre-segwit scripts but not segwit scripts
+            for (int k = 0; k < nSigsCount; k++)
+            {
+                valtype& vchSig = stacktop(-isig-k);
+                if (sigversion == SigVersion::BASE) {
+                    int found = FindAndDelete(scriptCode, CScript() << vchSig);
+                    if (found > 0 && (flags & SCRIPT_VERIFY_CONST_SCRIPTCODE))
+                        return set_error(serror, SCRIPT_ERR_SIG_FINDANDDELETE);
                 }
-                break;
-
-                case OP_CHECKSIG:
-                case OP_CHECKSIGVERIFY:
-                {
-                    // (sig pubkey -- bool)
-                    if (stack.size() < 2)
-                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
-
-                    valtype& vchSig    = stacktop(-2);
-                    valtype& vchPubKey = stacktop(-1);
-
-                    // Subset of script starting at the most recent codeseparator
-                    CScript scriptCode(pbegincodehash, pend);
-
-                    // Drop the signature in pre-segwit scripts but not segwit scripts
-                    if (sigversion == SigVersion::BASE) {
-                        int found = FindAndDelete(scriptCode, CScript() << vchSig);
-                        if (found > 0 && (flags & SCRIPT_VERIFY_CONST_SCRIPTCODE))
-                            return set_error(serror, SCRIPT_ERR_SIG_FINDANDDELETE);
-                    }
+            }
+            btc_sign_logf("scriptCode = %s\n", HexStr(scriptCode).c_str());
 
+            bool fSuccess = true;
+            btc_sign_logf("looping for multisig\n");
+            while (fSuccess && nSigsCount > 0)
+            {
+                btc_sign_logf("loop: sigs = %d, keys = %d\n", nSigsCount, nKeysCount);
+                valtype& vchSig    = stacktop(-isig);
+                valtype& vchPubKey = stacktop(-ikey);
+                std::string sig_str = HexStr(vchSig);
+                std::string pub_str = HexStr(vchPubKey);
+                btc_sign_logf("- got sig %s\n", sig_str.c_str());
+                btc_sign_logf("- got key %s\n", pub_str.c_str());
+
+                bool fOk;
+                if (pretend_valid_pubkeys.count(vchPubKey)) {
+                    fOk = pretend_valid_map.count(vchSig) && pretend_valid_map.at(vchSig) == vchPubKey;
+                    if (!fOk) btc_sign_logf("- [mock] wrong pubkey for sig; marking as failed\n");
+                } else {
+                    // Note how this makes the exact order of pubkey/signature evaluation
+                    // distinguishable by CHECKMULTISIG NOT if the STRICTENC flag is set.
+                    // See the script_(in)valid tests for details.
                     if (!CheckSignatureEncoding(vchSig, flags, serror) || !CheckPubKeyEncoding(vchPubKey, flags, sigversion, serror)) {
-                        //serror is set
+                        // serror is set
+                        btc_sign_logf("! CheckSignatureEncoding() or CheckPubKeyEncoding() failed!\n");
                         return false;
                     }
-                    bool fSuccess = checker.CheckSig(vchSig, vchPubKey, scriptCode, sigversion);
-
-                    if (!fSuccess && (flags & SCRIPT_VERIFY_NULLFAIL) && vchSig.size())
-                        return set_error(serror, SCRIPT_ERR_SIG_NULLFAIL);
 
-                    popstack(stack);
-                    popstack(stack);
-                    stack.push_back(fSuccess ? vchTrue : vchFalse);
-                    if (opcode == OP_CHECKSIGVERIFY)
-                    {
-                        if (fSuccess)
-                            popstack(stack);
-                        else
-                            return set_error(serror, SCRIPT_ERR_CHECKSIGVERIFY);
-                    }
+                    // Check signature
+                    fOk = checker.CheckSig(vchSig, vchPubKey, scriptCode, sigversion);
                 }
-                break;
+                btc_sign_logf("- sig check %s\n", fOk ? "succeeded" : "failed");
 
-                case OP_CHECKMULTISIG:
-                case OP_CHECKMULTISIGVERIFY:
-                {
-                    // ([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)
-
-                    int i = 1;
-                    if ((int)stack.size() < i)
-                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
-
-                    int nKeysCount = CScriptNum(stacktop(-i), fRequireMinimal).getint();
-                    if (nKeysCount < 0 || nKeysCount > MAX_PUBKEYS_PER_MULTISIG)
-                        return set_error(serror, SCRIPT_ERR_PUBKEY_COUNT);
-                    nOpCount += nKeysCount;
-                    if (nOpCount > MAX_OPS_PER_SCRIPT)
-                        return set_error(serror, SCRIPT_ERR_OP_COUNT);
-                    int ikey = ++i;
-                    // ikey2 is the position of last non-signature item in the stack. Top stack item = 1.
-                    // With SCRIPT_VERIFY_NULLFAIL, this is used for cleanup if operation fails.
-                    int ikey2 = nKeysCount + 2;
-                    i += nKeysCount;
-                    if ((int)stack.size() < i)
-                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
-
-                    int nSigsCount = CScriptNum(stacktop(-i), fRequireMinimal).getint();
-                    if (nSigsCount < 0 || nSigsCount > nKeysCount)
-                        return set_error(serror, SCRIPT_ERR_SIG_COUNT);
-                    int isig = ++i;
-                    i += nSigsCount;
-                    if ((int)stack.size() < i)
-                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
-
-                    // Subset of script starting at the most recent codeseparator
-                    CScript scriptCode(pbegincodehash, pend);
-
-                    // Drop the signature in pre-segwit scripts but not segwit scripts
-                    for (int k = 0; k < nSigsCount; k++)
-                    {
-                        valtype& vchSig = stacktop(-isig-k);
-                        if (sigversion == SigVersion::BASE) {
-                            int found = FindAndDelete(scriptCode, CScript() << vchSig);
-                            if (found > 0 && (flags & SCRIPT_VERIFY_CONST_SCRIPTCODE))
-                                return set_error(serror, SCRIPT_ERR_SIG_FINDANDDELETE);
-                        }
-                    }
+                if (fOk) {
+                    isig++;
+                    nSigsCount--;
+                }
+                ikey++;
+                nKeysCount--;
+
+                // If there are more signatures left than keys left,
+                // then too many signatures have failed. Exit early,
+                // without checking any further signatures.
+                if (nSigsCount > nKeysCount)
+                    fSuccess = false;
+            }
+            btc_sign_logf("loop ended in %s state\n", fSuccess ? "successful" : "failure");
+
+            // Clean up stack of actual arguments
+            while (i-- > 1) {
+                // If the operation failed, we require that all signatures must be empty vector
+                if (!fSuccess && (flags & SCRIPT_VERIFY_NULLFAIL) && !ikey2 && stacktop(-1).size())
+                    return set_error(serror, SCRIPT_ERR_SIG_NULLFAIL);
+                if (ikey2 > 0)
+                    ikey2--;
+                popstack(stack);
+            }
 
-                    bool fSuccess = true;
-                    while (fSuccess && nSigsCount > 0)
-                    {
-                        valtype& vchSig    = stacktop(-isig);
-                        valtype& vchPubKey = stacktop(-ikey);
-
-                        // Note how this makes the exact order of pubkey/signature evaluation
-                        // distinguishable by CHECKMULTISIG NOT if the STRICTENC flag is set.
-                        // See the script_(in)valid tests for details.
-                        if (!CheckSignatureEncoding(vchSig, flags, serror) || !CheckPubKeyEncoding(vchPubKey, flags, sigversion, serror)) {
-                            // serror is set
-                            return false;
-                        }
-
-                        // Check signature
-                        bool fOk = checker.CheckSig(vchSig, vchPubKey, scriptCode, sigversion);
-
-                        if (fOk) {
-                            isig++;
-                            nSigsCount--;
-                        }
-                        ikey++;
-                        nKeysCount--;
-
-                        // If there are more signatures left than keys left,
-                        // then too many signatures have failed. Exit early,
-                        // without checking any further signatures.
-                        if (nSigsCount > nKeysCount)
-                            fSuccess = false;
-                    }
+            // A bug causes CHECKMULTISIG to consume one extra argument
+            // whose contents were not checked in any way.
+            //
+            // Unfortunately this is a potential source of mutability,
+            // so optionally verify it is exactly equal to zero prior
+            // to removing it from the stack.
+            if (stack.size() < 1)
+                return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
+            if ((flags & SCRIPT_VERIFY_NULLDUMMY) && stacktop(-1).size()) {
+                printf("\n* * * * * * *\n\nHint: with Segwit activation, the OP_CHECKMULTISIG extra argument must be set to the empty push value (0x). If you are experimenting with older scripts, you may run into a 'Dummy CHECKMULTISIG argument must be zero' error. To move past this, you need to modify the verification flags, disabling the NULLDUMMY flag specifically. I.e. call btcdeb again with -f\"-NULLDUMMY\"\n\n* * * * * * *\n\n");
+                return set_error(serror, SCRIPT_ERR_SIG_NULLDUMMY);
+            }
+            popstack(stack);
 
-                    // Clean up stack of actual arguments
-                    while (i-- > 1) {
-                        // If the operation failed, we require that all signatures must be empty vector
-                        if (!fSuccess && (flags & SCRIPT_VERIFY_NULLFAIL) && !ikey2 && stacktop(-1).size())
-                            return set_error(serror, SCRIPT_ERR_SIG_NULLFAIL);
-                        if (ikey2 > 0)
-                            ikey2--;
-                        popstack(stack);
-                    }
+            pushstack(stack, fSuccess ? vchTrue : vchFalse);
 
-                    // A bug causes CHECKMULTISIG to consume one extra argument
-                    // whose contents were not checked in any way.
-                    //
-                    // Unfortunately this is a potential source of mutability,
-                    // so optionally verify it is exactly equal to zero prior
-                    // to removing it from the stack.
-                    if (stack.size() < 1)
-                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
-                    if ((flags & SCRIPT_VERIFY_NULLDUMMY) && stacktop(-1).size())
-                        return set_error(serror, SCRIPT_ERR_SIG_NULLDUMMY);
+            if (opcode == OP_CHECKMULTISIGVERIFY)
+            {
+                if (fSuccess)
                     popstack(stack);
+                else
+                    return set_error(serror, SCRIPT_ERR_CHECKMULTISIGVERIFY);
+            }
+        }
+        break;
 
-                    stack.push_back(fSuccess ? vchTrue : vchFalse);
+        default:
+            return set_error(serror, SCRIPT_ERR_BAD_OPCODE);
+    }
 
-                    if (opcode == OP_CHECKMULTISIGVERIFY)
-                    {
-                        if (fSuccess)
-                            popstack(stack);
-                        else
-                            return set_error(serror, SCRIPT_ERR_CHECKMULTISIGVERIFY);
-                    }
-                }
-                break;
+    // Size limits
+    if (stack.size() + altstack.size() > MAX_STACK_SIZE)
+        return set_error(serror, SCRIPT_ERR_STACK_SIZE);
 
-                default:
-                    return set_error(serror, SCRIPT_ERR_BAD_OPCODE);
-            }
+    return true;
+}
+
+ScriptExecutionEnvironment::ScriptExecutionEnvironment(std::vector<std::vector<unsigned char> >& stack_in, const CScript& script_in, unsigned int flags_in, const BaseSignatureChecker& checker_in)
+: script(script_in)
+, pend(script.end())
+, pbegincodehash(script.begin())
+, nOpCount(0)
+, fRequireMinimal((flags_in & SCRIPT_VERIFY_MINIMALDATA) != 0)
+, stack(stack_in)
+, flags(flags_in)
+, checker(checker_in)
+{}
+
+bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror)
+{
+    ScriptExecutionEnvironment env(stack, script, flags, checker);
+    CScript::const_iterator pc = env.script.begin();
+    set_error(serror, SCRIPT_ERR_UNKNOWN_ERROR);
+    if (env.script.size() > MAX_SCRIPT_SIZE)
+        return set_error(serror, SCRIPT_ERR_SCRIPT_SIZE);
 
-            // Size limits
-            if (stack.size() + altstack.size() > MAX_STACK_SIZE)
-                return set_error(serror, SCRIPT_ERR_STACK_SIZE);
+    try {
+        while (pc < env.pend) {
+            if (!StepScript(env, pc)) {
+                return false;
+            }
         }
     }
     catch (...)
@@ -1077,7 +1124,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&
         return set_error(serror, SCRIPT_ERR_UNKNOWN_ERROR);
     }
 
-    if (!vfExec.empty())
+    if (!env.vfExec.empty())
         return set_error(serror, SCRIPT_ERR_UNBALANCED_CONDITIONAL);
 
     return set_success(serror);
@@ -1118,7 +1165,9 @@ public:
             if (opcode == OP_CODESEPARATOR)
                 nCodeSeparators++;
         }
+        btc_sign_logf(" << scriptCode.size()=%zu - nCodeSeparators=%d\n", scriptCode.size(), nCodeSeparators);
         ::WriteCompactSize(s, scriptCode.size() - nCodeSeparators);
+        btc_sign_logf(" << script:"); print_vec(scriptCode, btc_sign_logf); btc_sign_logf("\n");
         it = itBegin;
         while (scriptCode.GetOp(it, opcode)) {
             if (opcode == OP_CODESEPARATOR) {
@@ -1134,50 +1183,71 @@ public:
     template<typename S>
     void SerializeInput(S &s, unsigned int nInput) const {
         // In case of SIGHASH_ANYONECANPAY, only the input being signed is serialized
-        if (fAnyoneCanPay)
+        if (fAnyoneCanPay) {
             nInput = nIn;
+            btc_sign_logf("    (fAnyoneCanPay: nInput = nIn)\n");
+        }
         // Serialize the prevout
+        btc_sign_logf(" << txTo.vin[nInput=%d].prevout = %s\n", nInput, txTo.vin[nInput].prevout.ToString().c_str());
         ::Serialize(s, txTo.vin[nInput].prevout);
         // Serialize the script
-        if (nInput != nIn)
+        if (nInput != nIn) {
             // Blank out other inputs' signatures
+            btc_sign_logf(" << [empty script] (reason: nInput != nIn)\n");
             ::Serialize(s, CScript());
-        else
+        } else {
+            btc_sign_logf("(SerializeScriptCode)\n");
             SerializeScriptCode(s);
+        }
         // Serialize the nSequence
-        if (nInput != nIn && (fHashSingle || fHashNone))
+        if (nInput != nIn && (fHashSingle || fHashNone)) {
             // let the others update at will
+            btc_sign_logf(" << sequence = 0 (nInput != nIn && (fHashSingle || fHashNone))\n");
             ::Serialize(s, (int)0);
-        else
+        } else {
+            btc_sign_logf(" << txTo.vin[nInput].nSequence = %u [0x%x]\n", txTo.vin[nInput].nSequence, txTo.vin[nInput].nSequence);
             ::Serialize(s, txTo.vin[nInput].nSequence);
+        }
     }
 
     /** Serialize an output of txTo */
     template<typename S>
     void SerializeOutput(S &s, unsigned int nOutput) const {
-        if (fHashSingle && nOutput != nIn)
+        if (fHashSingle && nOutput != nIn) {
             // Do not lock-in the txout payee at other indices as txin
+            btc_sign_logf(" << [empty txout] (reason: fHashSingle && nOutput=%d != nIn=%d)\n", nOutput, nIn);
             ::Serialize(s, CTxOut());
-        else
+        } else {
+            btc_sign_logf(" << txTo.vout[nOutput] = %s\n", txTo.vout[nOutput].ToString().c_str());
             ::Serialize(s, txTo.vout[nOutput]);
+        }
     }
 
     /** Serialize txTo */
     template<typename S>
     void Serialize(S &s) const {
+        btc_sign_logf("Serializing transaction\n");
         // Serialize nVersion
+        btc_sign_logf(" << txTo.nVersion (%08x)\n", txTo.nVersion);
         ::Serialize(s, txTo.nVersion);
         // Serialize vin
         unsigned int nInputs = fAnyoneCanPay ? 1 : txTo.vin.size();
+        btc_sign_logf(" << nInputs = %d [compact]\n", nInputs);
         ::WriteCompactSize(s, nInputs);
-        for (unsigned int nInput = 0; nInput < nInputs; nInput++)
-             SerializeInput(s, nInput);
+        for (unsigned int nInput = 0; nInput < nInputs; nInput++) {
+            btc_sign_logf("(serialize input %d)\n", nInput);
+            SerializeInput(s, nInput);
+        }
         // Serialize vout
         unsigned int nOutputs = fHashNone ? 0 : (fHashSingle ? nIn+1 : txTo.vout.size());
+        btc_sign_logf(" << nOutputs = %d [compact]\n", nOutputs);
         ::WriteCompactSize(s, nOutputs);
-        for (unsigned int nOutput = 0; nOutput < nOutputs; nOutput++)
-             SerializeOutput(s, nOutput);
+        for (unsigned int nOutput = 0; nOutput < nOutputs; nOutput++) {
+            btc_sign_logf("(serialize output %d)\n", nOutput);
+            SerializeOutput(s, nOutput);
+        }
         // Serialize nLockTime
+        btc_sign_logf(" << txTo.nLockTime = %d [0x%x]\n", txTo.nLockTime, txTo.nLockTime);
         ::Serialize(s, txTo.nLockTime);
     }
 };
@@ -1186,8 +1256,10 @@ template <class T>
 uint256 GetPrevoutHash(const T& txTo)
 {
     CHashWriter ss(SER_GETHASH, 0);
+    btc_sign_logf("- generating prevout hash from %zu ins\n", txTo.vin.size());
     for (const auto& txin : txTo.vin) {
         ss << txin.prevout;
+        btc_sign_logf("[+] %s\n", txin.prevout.ToString().c_str());
     }
     return ss.GetHash();
 }
@@ -1233,9 +1305,11 @@ template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTr
 template <class T>
 uint256 SignatureHash(const CScript& scriptCode, const T& txTo, unsigned int nIn, int nHashType, const CAmount& amount, SigVersion sigversion, const PrecomputedTransactionData* cache)
 {
+    btc_sign_logf("SignatureHash(nIn=%d, nHashType=%02x, amount=%lld)\n", nIn, nHashType, amount);
     assert(nIn < txTo.vin.size());
 
     if (sigversion == SigVersion::WITNESS_V0) {
+        btc_sign_logf("- sigversion == SIGVERSION_WITNESS_V0\n");
         uint256 hashPrevouts;
         uint256 hashSequence;
         uint256 hashOutputs;
@@ -1243,43 +1317,63 @@ uint256 SignatureHash(const CScript& scriptCode, const T& txTo, unsigned int nIn
 
         if (!(nHashType & SIGHASH_ANYONECANPAY)) {
             hashPrevouts = cacheready ? cache->hashPrevouts : GetPrevoutHash(txTo);
+            btc_sign_logf("  hashPrevouts = %s\n", hashPrevouts.ToString().c_str());
         }
 
         if (!(nHashType & SIGHASH_ANYONECANPAY) && (nHashType & 0x1f) != SIGHASH_SINGLE && (nHashType & 0x1f) != SIGHASH_NONE) {
             hashSequence = cacheready ? cache->hashSequence : GetSequenceHash(txTo);
+            btc_sign_logf("  hashSequence = %s\n", hashSequence.ToString().c_str());
         }
 
 
         if ((nHashType & 0x1f) != SIGHASH_SINGLE && (nHashType & 0x1f) != SIGHASH_NONE) {
             hashOutputs = cacheready ? cache->hashOutputs : GetOutputsHash(txTo);
+            btc_sign_logf("  hashOutputs [!single] = %s\n", hashOutputs.ToString().c_str());
         } else if ((nHashType & 0x1f) == SIGHASH_SINGLE && nIn < txTo.vout.size()) {
             CHashWriter ss(SER_GETHASH, 0);
             ss << txTo.vout[nIn];
             hashOutputs = ss.GetHash();
+            btc_sign_logf("  hashOutputs [single] = %s\n", hashOutputs.ToString().c_str());
         }
 
+        CHashWriter::debug = btc_enabled(btc_sighash_logf);
         CHashWriter ss(SER_GETHASH, 0);
         // Version
+        btc_sign_logf("SERIALIZING:\n");
         ss << txTo.nVersion;
+        btc_sign_logf(" << txTo.nVersion = %d\n", txTo.nVersion);
         // Input prevouts/nSequence (none/all, depending on flags)
         ss << hashPrevouts;
+        btc_sign_logf(" << hashPrevouts\n");
         ss << hashSequence;
+        btc_sign_logf(" << hashSequence\n");
         // The input being signed (replacing the scriptSig with scriptCode + amount)
         // The prevout may already be contained in hashPrevout, and the nSequence
         // may already be contain in hashSequence.
         ss << txTo.vin[nIn].prevout;
+        btc_sign_logf(" << txTo.vin[nIn=%d].prevout = %s\n", nIn, txTo.vin[nIn].prevout.ToString().c_str());
         ss << scriptCode;
+        btc_sign_logf(" << scriptCode\n");
         ss << amount;
+        btc_sign_logf(" << amount = %" PRId64 "\n", amount);
         ss << txTo.vin[nIn].nSequence;
+        btc_sign_logf(" << txTo.vin[nIn].nSequence = %u (0x%x)\n", txTo.vin[nIn].nSequence, txTo.vin[nIn].nSequence);
         // Outputs (none/one/all, depending on flags)
         ss << hashOutputs;
+        btc_sign_logf(" << hashOutputs\n");
         // Locktime
         ss << txTo.nLockTime;
+        btc_sign_logf(" << txTo.nLockTime = %d\n", txTo.nLockTime);
         // Sighash type
         ss << nHashType;
+        btc_sign_logf(" << nHashType = %02x\n", nHashType);
+        CHashWriter::debug = false;
+        uint256 sighash = ss.GetHash();
+        btc_sign_logf("RESULTING HASH = %s\n", sighash.ToString().c_str());
 
-        return ss.GetHash();
+        return sighash;
     }
+    btc_sign_logf("- sigversion = SIGVERSION_BASE (non-segwit style)\n");
 
     static const uint256 one(uint256S("0000000000000000000000000000000000000000000000000000000000000001"));
 
@@ -1287,6 +1381,7 @@ uint256 SignatureHash(const CScript& scriptCode, const T& txTo, unsigned int nIn
     if ((nHashType & 0x1f) == SIGHASH_SINGLE) {
         if (nIn >= txTo.vout.size()) {
             //  nOut out of range
+            btc_sign_logf("  nIn >= txTo.vout.size()\n");
             return one;
         }
     }
@@ -1295,35 +1390,52 @@ uint256 SignatureHash(const CScript& scriptCode, const T& txTo, unsigned int nIn
     CTransactionSignatureSerializer<T> txTmp(txTo, scriptCode, nIn, nHashType);
 
     // Serialize and hash
+    CHashWriter::debug = btc_enabled(btc_sighash_logf);
     CHashWriter ss(SER_GETHASH, 0);
     ss << txTmp << nHashType;
+    CHashWriter::debug = false;
     return ss.GetHash();
 }
 
 template <class T>
 bool GenericTransactionSignatureChecker<T>::VerifySignature(const std::vector<unsigned char>& vchSig, const CPubKey& pubkey, const uint256& sighash) const
 {
-    return pubkey.Verify(sighash, vchSig);
+    btc_sign_logf("  pubkey.Verify(sig="); print_vec(vchSig, btc_sign_logf); btc_sign_logf(", sighash=%s):\n", sighash.ToString().c_str());
+    bool res = pubkey.Verify(sighash, vchSig);
+    btc_sign_logf("  result: %s\n", res ? "success" : "FAILURE");
+    return res;
 }
 
 template <class T>
 bool GenericTransactionSignatureChecker<T>::CheckSig(const std::vector<unsigned char>& vchSigIn, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const
 {
+    btc_sign_logf("GenericTransactionSignatureChecker::CheckSig(%zu len sig, %zu len pubkey, sigversion=%d)\n", vchSigIn.size(), vchPubKey.size(), sigversion);
+    btc_sign_logf("  sig         = "); print_vec(vchSigIn, btc_sign_logf); btc_sign_logf("\n");
+    btc_sign_logf("  pub key     = "); print_vec(vchPubKey, btc_sign_logf); btc_sign_logf("\n");
+    btc_sign_logf("  script code = "); print_vec(scriptCode, btc_sign_logf); btc_sign_logf("\n");
     CPubKey pubkey(vchPubKey);
-    if (!pubkey.IsValid())
+    if (!pubkey.IsValid()) {
+        btc_sign_logf("- failed: pubkey is not valid\n");
         return false;
+    }
 
     // Hash type is one byte tacked on to the end of the signature
     std::vector<unsigned char> vchSig(vchSigIn);
-    if (vchSig.empty())
+    if (vchSig.empty()) {
+        btc_sign_logf("- failed: signature is empty\n");
         return false;
+    }
     int nHashType = vchSig.back();
     vchSig.pop_back();
+    btc_sign_logf("  hash type   = %02x (%s)\n", nHashType, hashtype_str(nHashType).c_str());
 
     uint256 sighash = SignatureHash(scriptCode, *txTo, nIn, nHashType, amount, sigversion, this->txdata);
+    btc_sign_logf("  sighash     = %s\n", sighash.ToString().c_str());
 
-    if (!VerifySignature(vchSig, pubkey, sighash))
+    if (!VerifySignature(vchSig, pubkey, sighash)) {
+        btc_sign_logf("- failed: VerifySignature() failed\n");
         return false;
+    }
 
     return true;
 }
diff --git a/script/interpreter.h b/script/interpreter.h
index 276ff9a..fa4944f 100644
--- a/script/interpreter.h
+++ b/script/interpreter.h
@@ -185,6 +185,28 @@ public:
 using TransactionSignatureChecker = GenericTransactionSignatureChecker<CTransaction>;
 using MutableTransactionSignatureChecker = GenericTransactionSignatureChecker<CMutableTransaction>;
 
+struct ScriptExecutionEnvironment {
+    CScript script;
+    CScript::const_iterator pend;
+    CScript::const_iterator pbegincodehash;
+    opcodetype opcode;
+    std::vector<uint8_t> vchPushValue;
+    std::vector<bool> vfExec;
+    std::vector<std::vector<uint8_t>> altstack;
+    int nOpCount;
+    bool fRequireMinimal;
+    std::vector<std::vector<unsigned char> >& stack;
+    unsigned int flags;
+    const BaseSignatureChecker& checker;
+    SigVersion sigversion;
+    ScriptError* serror;
+    std::map<std::vector<unsigned char>,std::vector<unsigned char>> pretend_valid_map;
+    std::set<std::vector<unsigned char>> pretend_valid_pubkeys;
+    ScriptExecutionEnvironment(std::vector<std::vector<unsigned char> >& stack_in, const CScript& script_in, unsigned int flags_in, const BaseSignatureChecker& checker_in);
+};
+
+bool StepScript(ScriptExecutionEnvironment& env, CScript::const_iterator& pc, CScript* local_script = nullptr);
+
 bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* error = nullptr);
 bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CScriptWitness* witness, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror = nullptr);
 
diff --git a/script/script.h b/script/script.h
index 6355b8a..83807f6 100644
--- a/script/script.h
+++ b/script/script.h
@@ -1,5 +1,5 @@
 // Copyright (c) 2009-2010 Satoshi Nakamoto
-// Copyright (c) 2009-2018 The Bitcoin Core developers
+// Copyright (c) 2009-2017 The Bitcoin Core developers
 // Distributed under the MIT software license, see the accompanying
 // file COPYING or http://www.opensource.org/licenses/mit-license.php.
 
@@ -38,12 +38,6 @@ static const int MAX_STACK_SIZE = 1000;
 // otherwise as UNIX timestamp.
 static const unsigned int LOCKTIME_THRESHOLD = 500000000; // Tue Nov  5 00:53:20 1985 UTC
 
-// Maximum nLockTime. Since a lock time indicates the last invalid timestamp, a
-// transaction with this lock time will never be valid unless lock time
-// checking is disabled (by setting all input sequence numbers to
-// SEQUENCE_FINAL).
-static const uint32_t LOCKTIME_MAX = 0xFFFFFFFFU;
-
 template <typename T>
 std::vector<unsigned char> ToByteVector(const T& in)
 {
@@ -317,6 +311,8 @@ public:
         return m_value;
     }
 
+    int64_t getint64() const { return m_value; }
+
     std::vector<unsigned char> getvch() const
     {
         return serialize(m_value);
@@ -437,9 +433,7 @@ public:
 
     explicit CScript(opcodetype b)     { operator<<(b); }
     explicit CScript(const CScriptNum& b) { operator<<(b); }
-    // delete non-existent constructor to defend against future introduction
-    // e.g. via prevector
-    explicit CScript(const std::vector<unsigned char>& b) = delete;
+    explicit CScript(const std::vector<unsigned char>& b) { operator<<(b); }
 
 
     CScript& operator<<(int64_t b) { return push_int64(b); }
@@ -567,6 +561,8 @@ public:
     }
 };
 
+typedef CScript::const_iterator CScriptIter;
+
 struct CScriptWitness
 {
     // Note that this encodes the data elements being pushed, rather than
@@ -583,4 +579,13 @@ struct CScriptWitness
     std::string ToString() const;
 };
 
+class CReserveScript
+{
+public:
+    CScript reserveScript;
+    virtual void KeepScript() {}
+    CReserveScript() {}
+    virtual ~CReserveScript() {}
+};
+
 #endif // BITCOIN_SCRIPT_SCRIPT_H
diff --git a/test/signing.cpp b/test/signing.cpp
index 448df39..aeca792 100644
--- a/test/signing.cpp
+++ b/test/signing.cpp
@@ -29,7 +29,7 @@ TEST_CASE("Segwit Multisig Signing", "[signing-segwit-multisig]") {
         // script should have 6 entries
         {
             size_t count = 0;
-            CScriptIter it = instance.script.begin();
+            CScript::const_iterator it = instance.script.begin();
             opcodetype opcode;
             std::vector<uint8_t> pushval;
             while (instance.script.GetOp(it, opcode, pushval)) {
diff --git a/test/value.cpp b/test/value.cpp
index aab2830..c7a6c4c 100644
--- a/test/value.cpp
+++ b/test/value.cpp
@@ -23,7 +23,7 @@ TEST_CASE("Conversions", "[conversions]") {
             std::vector<uint8_t> data;
             CScript s;
             s << i;
-            CScriptIter pc = s.begin();
+            CScript::const_iterator pc = s.begin();
             opcodetype opcode;
             REQUIRE(s.GetOp(pc, opcode, data));
             // printf("%9lld: %-8s | %s\n", i, Value(i).hex_str().c_str(), HexStr(data).c_str());
diff --git a/util/strencodings.h b/util/strencodings.h
index e35b2ab..a8aad78 100644
--- a/util/strencodings.h
+++ b/util/strencodings.h
@@ -16,6 +16,8 @@
 #include <string>
 #include <vector>
 
+#include <functional>
+
 #define ARRAYLEN(array)     (sizeof(array)/sizeof((array)[0]))
 
 /** Used by SanitizeString() */
@@ -171,6 +173,18 @@ bool TimingResistantEqual(const T& a, const T& b)
  */
 NODISCARD bool ParseFixedPoint(const std::string &val, int decimals, int64_t *amount_out);
 
+template <typename Tset, typename Tel>
+inline std::string Join(const Tset& iterable, const std::string& sep,
+        std::function<std::string(const Tel&)> strfun) {
+    std::string rv = "";
+    for (const Tel& el : iterable) {
+        rv += (rv[0] ? ", " : "") + strfun(el);
+    }
+    return rv;
+}
+
+inline std::string JoinHexStrFun(const std::vector<unsigned char>& t) { return HexStr(t); }
+
 /** Convert from one power-of-2 number base to another. */
 template<int frombits, int tobits, bool pad, typename O, typename I>
 bool ConvertBits(const O& outfn, I it, I end) {
diff --git a/value.cpp b/value.cpp
index 3172f78..88ab96d 100644
--- a/value.cpp
+++ b/value.cpp
@@ -1,10 +1,12 @@
 #include <secp256k1.h>
 
-#include "value.h"
+#include <value.h>
 
 #include <support/allocators/secure.h>
 
+#include <uint256.h>
 #include <arith_uint256.h>
+#include <pubkey.h>
 
 static secp256k1_context* secp256k1_context_sign = nullptr;
 
@@ -21,7 +23,7 @@ Value Value::prepare_extraction(const Value& a, const Value& b) {
 bool Value::extract_values(std::vector<std::vector<uint8_t>>& values) {
     values.clear();
     CScript s(data.begin(), data.end());
-    CScriptIter pc = s.begin();
+    CScript::const_iterator pc = s.begin();
     opcodetype opcode;
     std::vector<uint8_t> vch;
     while (pc != s.end()) {
diff --git a/value.h b/value.h
index 91a2a70..97a29eb 100644
--- a/value.h
+++ b/value.h
@@ -4,7 +4,7 @@
 #include <inttypes.h>
 #include <vector>
 #include <string>
-#include <utilstrencodings.h>
+#include <util/strencodings.h>
 #include <debugger/script.h>
 #include <tinyformat.h>
 #include <crypto/sha256.h>
@@ -437,7 +437,7 @@ struct Value {
     void do_bech32enc() {
         data_value();
         std::vector<unsigned char> tmp = {0};
-        ConvertBits<8, 5, true>(tmp, data.begin(), data.end());
+        ConvertBits<8, 5, true>([&](unsigned char c) { tmp.push_back(c); }, data.begin(), data.end());
         str = bech32::Encode("bc", tmp);
         type = T_STRING;
     }
@@ -458,7 +458,7 @@ struct Value {
         type = T_DATA;
         data.clear();
         // The rest of the symbols are converted witness program bytes.
-        if (ConvertBits<5, 8, false>(data, bech.second.begin() + 1, bech.second.end())) {
+        if (ConvertBits<5, 8, false>([&](unsigned char c) { data.push_back(c); }, bech.second.begin() + 1, bech.second.end())) {
             if (version == 0) {
                 {
                     if (data.size() == 20) {
